using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;

namespace DotMake.CommandLine.SourceGeneration
{
    [Generator]
    public class CliCommandGenerator : IIncrementalGenerator
    {
        private static readonly Type Type = typeof(CliCommandGenerator);
        private static readonly string Version = Type.Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>()?.Version;
        private static readonly string RoslynVersion = typeof(IIncrementalGenerator).Assembly.GetCustomAttribute<AssemblyFileVersionAttribute>()?.Version;
        private static readonly Dictionary<string, int> GenerationCounts = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);

        public void Initialize(IncrementalGeneratorInitializationContext initializationContext)
        {
            var referenceDependantInfo = initializationContext.CompilationProvider
                .Select((compilation, cancellationToken) => new ReferenceDependantInfo(compilation));

            var cliCommandInfos = initializationContext.SyntaxProvider.ForAttributeWithMetadataName(
                CliCommandInfo.AttributeFullName,
                (syntaxNode, cancellationToken) => syntaxNode is ClassDeclarationSyntax
                                                            //skip nested classes as they will be handled by the parent classes
                                                            && !(syntaxNode.Parent is TypeDeclarationSyntax),
                (attributeSyntaxContext, cancellationToken) => new CliCommandInfo(attributeSyntaxContext)
            );

            initializationContext.RegisterSourceOutput(referenceDependantInfo, GenerateReferenceDependantSourceCode);
            initializationContext.RegisterSourceOutput(cliCommandInfos, GenerateSourceCode);
        }

        private static void GenerateReferenceDependantSourceCode(SourceProductionContext sourceProductionContext, ReferenceDependantInfo referenceDependantInfo)
        {
            //Console.Beep(1000, 200); // For testing, how many times the generator is hit

            //For supporting ModuleInitializerAttribute in projects before net5.0 (net472, netstandard2.0)
            if (!referenceDependantInfo.HasModuleInitializer)
                sourceProductionContext.AddSource(
                    "[ModuleInitializerAttribute].g.cs",
                    GetSourceTextFromEmbeddedResource("ModuleInitializerAttribute.cs")
                );

            if (referenceDependantInfo.HasMsDependencyInjection)
                sourceProductionContext.AddSource(
                    "[CliServiceExtensions].g.cs",
                    GetSourceTextFromEmbeddedResource("CliServiceExtensions.cs")
                );
        }

        private static void GenerateSourceCode(SourceProductionContext sourceProductionContext, CliCommandInfo cliCommandInfo)
        {
            try
            {
                //Console.Beep(1000, 200); // For testing, how many times the generator is hit

                if (cliCommandInfo.SemanticModel.Compilation.Language != LanguageNames.CSharp)
                {
                    sourceProductionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ErrorUnsupportedLanguage, Location.None));
                    return;
                }
                if (cliCommandInfo.SyntaxNode.SyntaxTree.Options is CSharpParseOptions options && options.LanguageVersion < LanguageVersion.CSharp7_3)
                {
                    sourceProductionContext.ReportDiagnostic(Diagnostic.Create(DiagnosticDescriptors.ErrorUnsupportedLanguageVersion, Location.None));
                    return;
                }

                cliCommandInfo.ReportDiagnostics(sourceProductionContext);

                if (cliCommandInfo.HasProblem)
                    return;

                if (GenerationCounts.TryGetValue(cliCommandInfo.GeneratedClassFullName, out var generationCount))
                    GenerationCounts[cliCommandInfo.GeneratedClassFullName] = ++generationCount;
                else
                    GenerationCounts.Add(cliCommandInfo.GeneratedClassFullName, ++generationCount);

                var sb = new CodeStringBuilder();
                sb.AppendLine("// <auto-generated />");
                sb.AppendLine($"// Generated by {Type.Namespace} v{Version}");
                sb.AppendLine($"// Roslyn (Microsoft.CodeAnalysis) v{RoslynVersion}");
                sb.AppendLine($"// Generation: {generationCount}");
                //add time only for debug as it causes unnecessary changes in source control in TestApp with EmitCompilerGeneratedFiles
                //sb.AppendLine($"// Time: {DateTime.Now:o}, Generation: {generationCount}");
                sb.AppendLine();

                cliCommandInfo.AppendCSharpDefineString(sb, true);

                var generatedClassSourceCode = sb.ToString();

                //We need to use a stable hash to have a unique and short hintName.
                //Counting generated file names is not reliable, seems to sometimes run in parallel.
                //Using class full name can still collide because AddSource uses OrdinalIgnoreCase,
                //e.g. Namespace.Class1 and Namespace.class1 would collide
                //https://github.com/dotnet/roslyn/issues/48833
                var generatedFileName = $"{cliCommandInfo.GeneratedClassName}-{cliCommandInfo.GeneratedClassFullName.GetStableStringHashCode32()}.g.cs";

                sourceProductionContext.AddSource(generatedFileName, generatedClassSourceCode);
            }
            catch (Exception exception)
            {
                var diagnosticDescriptor = DiagnosticDescriptors.Create(exception);
                var diagnostic = Diagnostic.Create(diagnosticDescriptor, cliCommandInfo.Symbol.Locations.FirstOrDefault());

                sourceProductionContext.ReportDiagnosticSafe(diagnostic);
            }
        }

        private static SourceText GetSourceTextFromEmbeddedResource(string fileName)
        {
            using (var resourceStream = Type.Assembly.GetManifestResourceStream($"{Type.Namespace}.Embedded.{fileName}"))
            {
                if (resourceStream == null)
                    throw new Exception($"Embedded resource '{fileName}' is not found in assembly '{Type.Assembly}'.");

                return SourceText.From(resourceStream, canBeEmbedded: true);
            }
        }
    }
}
